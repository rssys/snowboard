#!/usr/bin/python3
"""
concurrent test executor

This module starts the execution environment for concurrent test inputs generated by 
the generator.py. It is ran by an experiment worker node as an enqueued redis task, 
enqueued by generator.py. 

the main function `concurrent_executor()` performs the following operations:
- takes a batch of test cases generated by various strategies in generator.py
- configures the appropriate test parameters
- executes the tests using SKI (the concurrency testing hypervisor)

workflow:
- generator.py adds concurrent_executor() tasks to redis queues for each strategy
- worker processes fetch these tasks from their subscribed queues
- concurrent_executor() prepares and runs the actual concurrency tests 
- test results are stored in the specified storage directory

input:
- testcase_list: a list of test cases to execute, each containing memory operation details
  in the format: [write_addr, read_addr, write_ins, read_ins, write_value, read_value,
  write_byte, read_byte, double_read, write_id, read_id]
- task_name: identifier for the testing strategy (channel, ins-pair, etc.)
- testing_mode: flag to enable a reduced test set for debugging purposes

each test case is processed into environment variables that configure the test execution:
- SKI_INPUT1_RANGE, SKI_INPUT2_RANGE: test input ranges
- SKI_CPU1_PREEMPTION, SKI_CPU2_PREEMPTION: instruction pointers for preemption
- SKI_CPU1_PREEMPTION_VALUE, SKI_CPU2_PREEMPTION_VALUE: values for memory operations
- SKI_CHANNEL_ADDR: shared memory address, or PMC (potential memory channel)

the module detects whether to run in standard mode or ski-only mode based on the test cases.

usage:
  this module is not meant to be run directly. it's used as a worker in
  the snowboard distributed testing system via redis queue. generator.py
  enqueues it. 
"""

import sys
import os
import time
from datetime import datetime
import multiprocessing

from concurrent_common import TestCase

def check_environment():
    main_home = os.environ.get('MAIN_HOME')
    if main_home is None:
        print("Please source setup.sh")
        exit(1)
    return main_home

def build_command_parameters(testcase_list, ski_mode):
    input1  = 'SKI_INPUT1_RANGE=%'
    input2  = 'SKI_INPUT2_RANGE=%'
    preemp1 = 'SKI_CPU1_PREEMPTION='
    preemp2 = 'SKI_CPU2_PREEMPTION='
    value1  = 'SKI_CPU1_PREEMPTION_VALUE='
    value2  = 'SKI_CPU2_PREEMPTION_VALUE='
    addr    = 'SKI_CHANNEL_ADDR='
    
    for i, testcase in enumerate(testcase_list):
        is_last_entry = (i == len(testcase_list) - 1)
        separator     = ',' 
        if is_last_entry:
            separator = ''

        if ski_mode:
            input1 += str(testcase.double_read) + separator
            input2 += str(testcase.write_id)    + separator
            continue
            
        write_addr  = testcase.write_addr
        read_addr   = testcase.read_addr
        write_byte  = testcase.write_byte
        read_byte   = testcase.read_byte
        write_value = testcase.write_value
        read_value  = testcase.read_value
        
        write_addr_set = set([])
        read_addr_set  = set([])
        for addr_tmp in range(write_addr, write_addr + write_byte):
            write_addr_set.add(addr_tmp)
        for addr_tmp in range(read_addr, read_addr + read_byte):
            read_addr_set.add(addr_tmp)
        addr_begin = min(list(write_addr_set & read_addr_set))
        
        input1     += str(testcase.write_id)  + separator
        input2     += str(testcase.read_id)   + separator
        preemp1    += str(testcase.write_ins) + separator
        preemp2    += str(testcase.read_ins)  + separator
        value1     += str(write_value)        + separator
        value2     += str(read_value)         + separator
        addr       += str(addr_begin)         + separator
    
    return input1, input2, preemp1, preemp2, value1, value2, addr

def create_command(params, script, ski_mode):
    if ski_mode:
        input1, input2 = params[0], params[1]
        cmd =  f"{input1} {input2} SKI_PREEMPTION_BY_ACCESS=0 " 
        cmd += f"SKI_FORKALL_CONCURRENCY={multiprocessing.cpu_count()} "
        cmd += script
    else:
        input1, input2, preemp1, preemp2, value1, value2, addr = params
        cmd =  f"{input1} {input2} {preemp1} {preemp2} {addr} "
        cmd += f"{value1} {value2} SKI_PREEMPTION_BY_ACCESS=1 "
        cmd += f"SKI_FORKALL_CONCURRENCY={multiprocessing.cpu_count()} {script}"
    return cmd

def detect_ski_mode(testcase_list):
    for testcase in testcase_list:
        if testcase.write_addr == -1:
            return True
    return False

def concurrent_executor(testcase_list, task_name, testing_mode):
    main_home = check_environment()
    script = main_home + "/scripts/test/concurrent-test.sh"
    
    if testing_mode:
        testcase_list = testcase_list[:50]
    
    testcases = []
    for testcase in testcase_list:
        testcases.append(TestCase(*testcase))

    ski_mode = detect_ski_mode(testcases)
    params = build_command_parameters(testcases, ski_mode)
    cmd = create_command(params, script, ski_mode)
    
    print(cmd)
    os.system(cmd)